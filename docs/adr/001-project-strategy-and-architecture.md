# 📄 ADR 001: 기술 역량 증명을 위한 프로젝트 전략 및 아키텍처 선정

- **Status:** Accepted
- **Date:** 2025-12-25
- **Author:** @User (Lead Backend Engineer)
- **Deciders:** @User, @Gemini

## 1. Context (배경 및 문제 상황)

본 프로젝트 **'Time-Deal Service'**는 상용 서비스 출시가 아닌, **대규모 트래픽 환경에서의 고난도 백엔드 엔지니어링 역량을 증명**하기 위한 포트폴리오 프로젝트다.

일반적인 웹 애플리케이션 개발 방식(MVP)을 따를 경우, 다음과 같은 문제가 예상된다:

1. **리소스 분산:** 회원가입, 장바구니, 어드민 등 일반적인 비즈니스 기능(CRUD) 구현에 시간이 소요되어, 정작 중요한 동시성 제어나 장애 격리 같은 심층적인 기술을 다룰 시간이 부족하다.
2. **아키텍처 복잡성 관리:** 처음부터 마이크로서비스 아키텍처(MSA)를 도입할 경우, 인프라 관리 및 배포 복잡도가 증가하여 비즈니스 로직과 도메인 모델링에 집중하기 어렵다. 또한, 도메인 경계가 명확하지 않은 상태에서의 MSA 전환은 '분산된 모놀리스(Distributed Monolith)'를 초래할 위험이 있다.
3. **검증 목표와 아키텍처의 상충:** 대용량 트래픽 처리의 표준인 EDA(Event-Driven Architecture)는 트래픽 버퍼링 효과로 인해, 본 프로젝트의 핵심 목표인 **'DB 레벨의 동시성 경쟁(Race Condition) 해결 능력'**을 검증하는 데 방해가 될 수 있다.

따라서, **"제한된 시간 내에 최고의 기술적 밀도(Tech Density)를 보여줄 수 있는 전략과 구조"**가 필요하다.

## 2. Decision (의사 결정)

우리는 위 문제를 해결하기 위해 다음과 같은 전략과 아키텍처를 채택한다.

### 2.1. 전략: "Feature Minimal, Engineering Maximal"

비즈니스 기능은 최소화하고, 기술적 깊이는 극대화한다.

- **Business YAGNI:** 사용자 인증(Auth), 장바구니, 관리자 페이지, PG사 연동 등 아키텍처 검증과 무관한 기능은 구현하지 않는다.
    - *대안:* API 요청 헤더(`X-User-Id`)를 통한 가상 유저 식별, Mocking을 통한 외부 의존성 대체.
- **Tech Over-engineering:** 확보된 리소스를 활용하여 동시성 제어(Locking), 대용량 트래픽 처리, 시스템 안정성(Resilience) 확보에 과도할 만큼 집착한다.

### 2.2. 아키텍처: Domain-based Modular Monolith (도메인 중심 모듈러 모놀리스)

물리적으로는 하나의 배포 단위(Monolith)를 가지지만, 논리적으로는 완벽하게 격리된 모듈 구조를 채택한다.

- **Vertical Slicing (수직적 격리):** 기술 계층(`api`, `core`)이 아닌, 도메인(`product`, `order`, `payment`) 단위로 Gradle Sub-module을 분리한다.
    - *이점:* 특정 도메인을 마이크로서비스로 분리(Split)할 때, 해당 모듈 폴더만 추출하면 되므로 MSA 전환 비용이 0에 수렴한다.
- **No Common Module Initially (공통 모듈 배제):** '3의 원칙(Rule of Three)'을 적용하여, 중복 코드가 3번 이상 발견되기 전까지는 공통 모듈(`:common`)을 생성하지 않는다.
    - 섣부른 추상화(Premature Abstraction)로 인한 결합도 증가를 방지한다.
- **Hexagonal Style within Module:** 각 도메인 모듈 내부에서는 도메인 로직을 보호하기 위해 Port-Adapter 패턴을 적용한다.

### 2.3. 통신 방식: Critical Path에서의 동기(Synchronous) 통신 강제

주문 생성 및 재고 차감이 일어나는 핵심 경로(Critical Path)에서는 **Kafka 등을 이용한 비동기(Async) 처리를 의도적으로 배제하고, 동기적(Synchronous) 메서드 호출을 채택**한다.

- **Intentional Constraint (의도적 제약):**
    - 메시지 큐가 트래픽 버퍼 역할을 수행하여 DB 레벨에서의 극심한 **락 경합(Lock Contention)** 상황이 완화되거나 재현되지 않을 수 있다.
    - 우리는 **'제어되지 않은 날것의 트래픽'**이 DB에 도달했을 때 발생하는 문제를 직면하고, 이를 **DB Lock, Redis Distributed Lock, Lua Script** 등 다양한 기법으로 해결하는 과정을 보여주는 것을 최우선 목표로 한다.
- **Hybrid Approach:**
    - 단, 데이터 정합성이 확보된 이후의 로직(결제, 알림 등)은 **Sprint 4 단계에서 비동기 이벤트(Kafka)로 리팩토링**하여 시스템 안정성을 확보하는 과정을 별도로 보여준다.

## 3. Consequences (결과 및 트레이드오프)

### ✅ 긍정적 효과 (Positive)

- **고밀도 엔지니어링:** 프로젝트의 모든 코드가 채용 담당자에게 어필 가능한 기술적 고민의 결과물이 된다.
- **빠른 개발 및 피드백:** 단일 배포 단위이므로 로컬 개발, 테스트, 배포 파이프라인 구성이 단순하다.
- **명확한 도메인 경계:** 물리적인 모듈 분리를 통해 스파게티 코드를 방지하고, 강제적으로 '관심사의 분리(SoC)'를 실현한다.
- **동시성 문제의 명확한 재현:** Sync 방식은 트래픽 몰림 시 DB 리소스 경쟁을 적나라하게 드러내어 동시성 제어 기술 검증에 최적의 환경을 제공한다.

### ⚠️ 부정적 효과 및 대응 (Negative & Mitigation)

- **UX의 부재:** 실제 사용자가 사용할 수 있는 완전한 제품 형태가 아니다.
    - *Mitigation:* README 및 문서에 이 프로젝트가 'R&D 및 아키텍처 쇼케이스'임을 명시한다.
- **분산 시스템 경험의 한계:** 모놀리스 구조이므로 네트워크 지연(Latency)이나 분산 트랜잭션 문제를 물리적으로 체감하기 어렵다.
    - *Mitigation:* 추후 Sprint 4, 5 단계에서 Kafka 및 별도 Mock 서버를 도입하여 논리적인 분산 환경을 시뮬레이션하고 문제를 재현한다.
- **중복:** 초기에는 각 모듈에 중복된 설정 코드나 유틸리티 클래스가 생길 수 있다. (이는 '3의 원칙'에 따라 용인한다.)
- **강결합 및 트래픽 저항성 감소:** 초기에는 모듈 간 강결합이 발생하며 큐잉 없이 DB 부하가 급증한다.
    - *Mitigation:* 이는 의도된 설계이며, Redis Caching 도입의 근거로 삼는다. 추후 Non-Critical Path는 비동기 전환을 통해 개선한다.

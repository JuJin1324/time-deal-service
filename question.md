# ❓ 질문 & 답변 (Q&A)

---

## 1. 멀티 모듈 프로젝트에서 'API 모듈' (Application Bootstrapper)이 필요한 이유

### ❓ 질문:

"API 프로젝트가 C4 모델링에서 나온 '모듈 통합 및 실행 진입점'인 건 이해한다. 그런데 이게 꼭 필요한가? 각 모듈마다 진입점을 만드는 것보다 나은 점이 있는가? 각 모듈마다 Controller를 둘 계획인데, 사실상 Controller가 진입점 아닌가 하는 생각이 든다."

### 💡 답변:

결론적으로, 현재의 **모듈형 모놀리식(Modular Monolith) 아키텍처**에서는 별도의 `api` 모듈(Application Bootstrapper)이 있는 것이 훨씬 유리하며 필수적입니다. 그 이유는 다음과 같습니다.

1.  **단일 배포 단위 유지 (Monolithic Deployment):**
    *   우리의 목표는 "논리적으로는 분리되어 있지만, 물리적으로는 하나로 배포되는 모놀리스"를 만드는 것입니다.
    *   각 도메인 모듈(product, order, payment)이 자체적인 `main` 메서드(진입점)를 가진다면, 이는 각각 독립적인 마이크로서비스가 되어 배포 단위가 늘어납니다.
    *   `api` 모듈은 이 모든 도메인 모듈의 코드를 통합하여 **단 하나의 실행 가능한 JAR** 파일로 만들어주는 역할을 합니다. 이는 모놀리스 배포의 핵심입니다.

2.  **순환 참조 방지 및 엄격한 의존성 관리:**
    *   `product`, `order`, `payment`와 같은 도메인 모듈들은 서로를 직접 참조하지 않거나, 엄격한 단방향 의존성 규칙을 따라야 합니다.
    *   `api` 모듈이 이 모든 도메인 모듈을 의존(`implementation project`)하고, Spring의 `@ComponentScan`을 통해 모든 모듈의 컴포넌트(Controller, Service 등)를 스캔하여 하나의 애플리케이션 컨텍스트를 구성합니다. 이를 통해 도메인 모듈 간의 불필요한 직접적인 결합을 줄이고, `api` 모듈이 의존성의 중앙 허브 역할을 수행합니다.

3.  **Controller는 '코드의 진입점'이지 '애플리케이션 실행의 진입점'이 아니다:**
    *   각 도메인 모듈 내부에 `@RestController`를 두는 것은 HTTP 요청을 처리하는 "코드의 진입점" 역할을 합니다.
    *   하지만 Spring Boot 애플리케이션의 "실행 진입점"은 `api` 모듈의 `main` 메서드를 포함한 `@SpringBootApplication` 클래스입니다. 이 클래스가 Spring Context를 초기화하고 모든 빈(Bean)들을 등록하는 과정을 주도합니다.

**요약:**
`api` 모듈은 "흩어진 부품(도메인 모듈)들을 모아서 하나의 완성된 제품(단일 실행 가능 서버)으로 조립하는 역할"을 합니다. 이 구조는 현재 모놀리스의 장점을 유지하면서도, 향후 필요시 각 도메인 모듈을 개별 마이크로서비스로 분리(Split)하기 용이하게 만들어주는 발판이 됩니다.

---

## 2. ArchUnit 테스트의 유지보수성 vs 효용성

### ❓ 질문:

"ArchUnit만 초반에 작성해두면 해당 테스트가 변화될 일이 없는 것인가? 그래야 자동화된 이점을 챙기면서 관리 포인트를 줄일 수가 있잖아. 근데 테스트가 자주 변해야하면 오히려 관리 포인트가 늘어나는 것이고 말이지?"

### 💡 답변:

ArchUnit 테스트는 초반에 잘 작성해두면 **"유지보수 비용은 거의 없으면서(Zero Maintenance), 효용은 지속되는(High Value)"** 가성비 최고의 테스트입니다.

1.  **규칙 기반 검사 (Rule-based Testing):**
    *   ArchUnit은 구체적인 비즈니스 로직을 검사하는 것이 아니라, **"모든 Controller는 Service 패키지에만 의존해야 한다"** 와 같은 **구조적 패턴(Pattern)**을 검사합니다.
    *   따라서 클래스나 기능이 수백 개 늘어나도, 이들이 정해진 패턴(규칙) 안에만 있다면 테스트 코드를 수정할 필요가 전혀 없습니다.

2.  **불변의 아키텍처 원칙:**
    *   "순환 참조 금지", "헥사고날 아키텍처 계층 준수" 같은 규칙은 프로젝트의 수명 주기 동안 변하지 않는 **불변의 대원칙**입니다.
    *   테스트가 수정되어야 하는 유일한 경우는 우리가 아키텍처 철학 자체를 바꾸기로 결정했을 때뿐입니다.

**결론:**
ArchUnit은 개발자가 코드를 추가할 때마다 아키텍처를 위반하지 않는지 자동으로 감시해주는 **"영구적인 안전장치"** 역할을 합니다.

---

## 3. ArchUnit 테스트를 API 모듈에만 적용한 이유

### ❓ 질문:

"현재 API 모듈의 테스트에만 ArchUnit 테스트를 적용했는데, API 모듈 외에 다른 모듈(product, order, payment)에는 ArchUnit 테스트를 적용하지 않아도 되는가?"

### 💡 답변:

네, **현재 설정으로 모든 모듈(`product`, `order`, `payment`)에 대한 아키텍처 검사가 수행됩니다.** 따라서 다른 모듈에 중복해서 ArchUnit 테스트를 작성할 필요는 없습니다.

이러한 접근 방식의 원리는 다음과 같습니다:

1.  **`api` 모듈의 "중앙 집중식 검사" 원리:**
    *   **의존성 포함:** `api` 모듈은 `product`, `order`, `payment` 모듈을 모두 의존하고 있습니다(`implementation project`). 즉, `api` 모듈의 테스트 실행 시점에는 이 모든 모듈의 클래스 파일들이 Java의 **Classpath**에 로드됩니다.
    *   **패키지 스캔 범위:** `ArchitectureTest` 클래스에 선언된 `@AnalyzeClasses(packages = "com.timedeal")` 어노테이션은 Classpath 내에서 `com.timedeal`로 시작하는 **모든 클래스**를 ArchUnit의 분석 대상으로 삼습니다.
    *   **결과:** 테스트 코드는 `api` 모듈에 위치하지만, 실제로는 `product`, `order`, `payment` 패키지를 포함한 프로젝트 전체의 `com.timedeal` 하위 패키지들이 검사 대상이 됩니다.

2.  **이 방식의 장점:**
    *   **전역적인 순환 참조 감지:** 개별 모듈에서는 감지하기 어려운 모듈 간의 전역적인 순환 참조(예: `product` -> `order` -> `product`)를 `api` 모듈에서 한 번에 잡아낼 수 있습니다.
    *   **규칙 관리의 일원화:** 아키텍처 규칙은 프로젝트 전체에 적용되는 표준이므로, 단일 위치(`api` 모듈)에서 관리하는 것이 유지보수 측면에서 효율적입니다. 규칙 변경 시 한 곳만 수정하면 됩니다.

3.  **단점 및 고려사항:**
    *   `product` 모듈만을 대상으로 `./gradlew :product:test`와 같이 개별 모듈 테스트를 실행할 경우, ArchUnit 검사는 실행되지 않습니다. 아키텍처 규칙 검증을 위해서는 반드시 `./gradlew :api:test` 또는 `./gradlew test` (전체 테스트)를 실행해야 합니다. 일반적으로 CI/CD 파이프라인에서는 전체 테스트가 수행되므로 이러한 문제는 해소됩니다.